1. Добавил функцию `run_once`
	* функция возвращает `0`, игра закончилась (больше нет активных процессов), и `1`, если еще игра не закончилась
2. Поля для визуалиции
	* `g_vm.nprocs` - число процессов
	* `g_vm.icycle` - номер цикла
	* `g_vm.procs` - начало односвязного списка процессов (напоминаю, что процессы и каретки – одно и то же). В `t_proc` есть поле `next`, которое указывает на следующий процесс в списке
	* `g_vm.curr_nlive` - количество исполненных `live` инструкций за текущий период (период – несколько циклов, за время которых ни одна каретка не была убита)
	* `g_vm.prev_nlive` - количество исполненных `live` инструкций за прошлый период
	* `g_vm.last_live_champ` - номер (индекс = номер - 1) чемпиона, который последним выполнил `live` инструкцию
	* `g_vm.cycles_to_die` - количество циклов до того, как каретки, не выполнившие ни одной `live` команды, будут убиты. Это число может быть отрицательным.
	* `CYCLE_DELTA` - макрос в `op.h`, который определяет, на сколько уменьшается `g_vm.cycles_to_die` за один раз
	* `NBR_LIVE` - макрос, конролирующий, как часто уменьшается `g_vm.cycles_to_die`
	* `MAX_CHECKS` – макрос, конролирующий, как часто уменьшается 
	* `proc->ichamp` - номер чемпиона, к которому принадлежит данный процесс
	* `proc->pc` - индекс текущего положения каретки в памяти

3. Дополнительно о визуализации
	* `champ->curr_nlive / g_vm.curr_nlive * 100%` даст процест от общего количества `live` инструкций, который были выполнены данным игроком за текущий период (АККУРАТНО, `g_vm.curr_nlive` может быть нулевым)
	* `champ->prev_nlive / g_vm.prev_nlive * 100%` даст процест от общего количества `live` инструкций, который были выполнены данным игроком за прошлый период (АККУРАТНО, `g_vm.prev_nlive` может быть нулевым)

4. Я еще не интегрировал функцию, которая бы отмечала, какий байты в памяти были изменены каким игроком, в `mem_write`
